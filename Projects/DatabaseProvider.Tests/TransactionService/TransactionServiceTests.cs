/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Data;
using NUnit.Framework;
using NUnitExtension.OutSystems.Framework;
using OutSystems.HubEdition.Extensibility.Data.TransactionService;
using OutSystems.RuntimeCommon.ObfuscationProperties;
using OutSystems.ServerTests.DatabaseProvider.Framework;

namespace OutSystems.ServerTests.DatabaseProvider.TransactionService {

    public class TestConfiguration : AgnosticDatabaseProviderTestConfiguration {

        protected override string ConfigurationPathSettingName {
            get {
                return "DatabaseProviderTests.TransactionServiceFilesPath";
            }
        }
    }

    public class ServerOnlyTestConfiguration : TestConfiguration {

        protected override bool IsServerOnly {
            get {
                return true;
            }
        }

    }

    [DashboardTestFixture(DashboardTest.DashboardTestKind)]
    public class TransactionServiceTests : DatabaseProviderTest<TestConfiguration> {

        private void WithTransactionManager(ITransactionManager tm, Action<ITransactionManager> action) {
            try {
                action(tm);
            } finally {
                try { tm.FreeupResources(false); } catch { }
            }

        }

        private void ExpectException(Type exceptionType, Action body) {

            Type gotException = null;
            try {
                body();
            } catch (Exception e) {
                gotException = e.GetType();
            }

            Assert.IsNotNull(gotException, "Should have thrown " + exceptionType.Name + " exception");
            Assert.AreEqual(exceptionType, gotException, "Should have thrown " + exceptionType.Name + " exception");
        }


        #region Transaction re-utilization based on transaction type and order

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof(ServerOnlyTestConfiguration), Description = "Getting a ReadOnlyTransaction after releasing it returns the same transaction")]
        public void GetConsecutiveTransactionsWithRelease(DatabaseProviderTestCase tc) {
            var services = tc.Services;
            WithTransactionManager(services.TransactionService.CreateTransactionManager(), (tm) => {
                IDbTransaction trans1 = tm.GetReadOnlyTransaction();
                tm.ReleaseTransaction(trans1);
                IDbTransaction trans2 = tm.GetReadOnlyTransaction();
                Assert.AreEqual(trans1, trans2);
            });
        }

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof(ServerOnlyTestConfiguration), Description = "Getting a PrivateTransaction after releasing a ReadOnlyTransaction doesn't return the same transaction")]
        public void GetConsecutiveTransactionsUsingPrivate(DatabaseProviderTestCase tc) {
            var services = tc.Services;
            WithTransactionManager(services.TransactionService.CreateTransactionManager(), (tm) => {
                IDbTransaction trans1 = tm.GetReadOnlyTransaction();
                tm.ReleaseTransaction(trans1);
                IDbTransaction trans2 = tm.GetCommitableTransaction();
                Assert.AreNotEqual(trans1, trans2, "Transactions must be different");
            });
        }

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof(ServerOnlyTestConfiguration), Description = "Consecutively getting the MainTransaction returns the same transaction")]
        public void GetRequestTransaction(DatabaseProviderTestCase tc) {
            var services = tc.Services;
            WithTransactionManager(services.TransactionService.CreateTransactionManager(), (tm) => {
                IDbTransaction trans1 = tm.GetRequestTransaction();
                IDbTransaction trans2 = tm.GetRequestTransaction();
                Assert.AreEqual(trans1, trans2);
            });
        }

        #endregion

        #region Commit, rollback and release exceptions

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof(ServerOnlyTestConfiguration), Description = "Releasing a Transaction causes an InvalidReleaseException")]
        public void PrivateTransactionNotReleasable(DatabaseProviderTestCase tc) {
            var services = tc.Services;
            ExpectException(typeof(InvalidTransactionReleaseException), () => {
                WithTransactionManager(services.TransactionService.CreateTransactionManager(), (tm) => {
                    IDbTransaction trans = tm.GetCommitableTransaction();
                    tm.ReleaseTransaction(trans);
                });
            });
        }

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof(ServerOnlyTestConfiguration), Description = "Commiting a ReadOnly Transaction causes an InvalidCommitOrRollbackException")]
        public void ReadOnlyTransactionNotCommitable(DatabaseProviderTestCase tc) {
            var services = tc.Services;
            ExpectException(typeof(InvalidCommitOrRollbackTransactionException), () => {
                WithTransactionManager(services.TransactionService.CreateTransactionManager(), (tm) => {
                    IDbTransaction trans = tm.GetReadOnlyTransaction();
                    tm.CommitTransaction(trans);
                });
            });
        }

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof(ServerOnlyTestConfiguration), Description = "Commiting a Main Transaction causes an InvalidCommitOrRollbackException")]
        public void MainTransactionNotCommitable(DatabaseProviderTestCase tc) {
            var services = tc.Services;
            ExpectException(typeof(InvalidCommitOrRollbackTransactionException), () => {
                WithTransactionManager(services.TransactionService.CreateTransactionManager(), (tm) => {
                    IDbTransaction trans = tm.GetRequestTransaction();
                    tm.CommitTransaction(trans);
                });
            });
        }
        #endregion

        #region Busy transaction pool count

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof(ServerOnlyTestConfiguration), Description = "Getting a PrivateTransactions increments busy transaction pool count")]
        public void BusyPrivateTransactionPoolCount(DatabaseProviderTestCase tc) {
            var services = tc.Services;
            WithTransactionManager(services.TransactionService.CreateTransactionManager(), (tm) => {
                int initialCount = tm.BusyTransactionCount;
                IDbTransaction privateTrans1 = tm.GetCommitableTransaction();
                Assert.IsTrue(tm.BusyTransactionCount == (initialCount + 1));
            });
        }

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof(ServerOnlyTestConfiguration), Description = "Freeing up resources zeroes busy transaction pool count")]
        public void FreeupResourcesClearsBusyTransactionPool(DatabaseProviderTestCase tc) {
            var services = tc.Services;
            WithTransactionManager(services.TransactionService.CreateTransactionManager(), (tm) => {
                IDbTransaction privateTrans1 = tm.GetCommitableTransaction();
                IDbTransaction privateTrans2 = tm.GetCommitableTransaction();
                tm.FreeupResources(false);
                Assert.IsTrue(tm.BusyTransactionCount == 0);
            });
        }

        #endregion
    }
}